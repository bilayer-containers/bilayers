import os
import gradio as gr
import subprocess
import shutil
import zipfile
from typing import Any, Optional
import uuid
import datetime
import glob

def option_to_append(cli_tag: str, value: Any) -> str:
    """
    Formats CLI options for appending to the command.

    Args:
        cli_tag (str): CLI tag (e.g., "--option").
        value (Any): The value to append.

    Returns:
        str: The formatted CLI option.
    """
    if value is None:
        return ""
    
    if cli_tag == "":
        return str(value)  # Append only the value
    elif "=" in cli_tag:
        return f"{cli_tag}{value}"
    return f"{cli_tag} {value}"  # Append cli_tag and value

def cli_tag_is_valid(cli_tag: Optional[str]) -> bool:
    """
    Checks if the CLI tag is valid (not None, not "None", not empty)

    Args:
        cli_tag (Optional[str]): The CLI tag to check

    Returns:
        bool: True if valid, False otherwise
    """
    return cli_tag not in [None, "None", ""]


def generate_cli_command(
    cli_sequence: list[dict[str, Any]], 
    **kwargs: Any
    ) -> tuple[str, Optional[str], Optional[str]]:
    """
    Generates the CLI command dynamically based on pre-ordered CLI sequence and user inputs

    Args:
        cli_sequence (list[dict[str, Any]]): Pre-ordered sequence of inputs/parameters/hidden_args.
        **kwargs (Any): User-provided parameter values.

    Returns:
        tuple[str, Optional[str], Optional[str]]: CLI command, folder_name, and output_folder_name.
    """
    cli_command = ["{{ exec_function.get("cli_command", "") }}"]

    # Radio options mapping
    radio_options = {
    {% if parameters %}
    {% for key, param_conf in parameters.items() if param_conf.get('type') in ['radio', 'dropdown'] -%}
        "{{ key | lower | replace(' ', '_') }}": {
            {% for option in param_conf.get('options', []) -%}
            "{{ option.get('label', '') }}": "{{ option.get('value', '') }}"{% if not loop.last %}, {% endif %}
            {%- endfor %}
        },
    {%- endfor %}
    {%- endif %}
    {% if display_only %}
    {% for key, display_only_conf in display_only.items() if display_only_conf.get('type') in ['radio', 'dropdown'] -%}
        "{{ key | lower | replace(' ', '_') }}": {
            {% for option in display_only_conf.get('options', []) -%}
            "{{ option.get('label', '') }}": "{{ option.get('value', '') }}"{% if not loop.last %}, {% endif %}
            {%- endfor %}
        },
    {%- endfor %}
    {%- endif %}
    }

    folder_name = None
    output_folder_name = None

    # Iterate through the pre-ordered CLI sequence
    for item in cli_sequence:
        name = item.get("name", "")
        source = item.get("source", "")
        cli_tag = item.get("cli_tag", "")
        item_type = item.get("type", "")
        optional = item.get("optional", False)
        label = item.get("label", "")
        append_value = item.get("append_value", False)
        
        # Get value from kwargs (user input) or use default
        if source == "hidden":
            # Hidden arguments always use their configured value
            value = item.get("value", "")
        else:
            # Regular inputs/parameters: use user input if provided, else use default
            param_key = name.lower().replace(" ", "_")
            value = kwargs.get(param_key, item.get("default"))

        # Skip processing if value is None/empty and optional
        if value in [None, "", "None"] and optional:
            continue

        # Validate mandatory parameters
        if value in [None, "", "None"] and not optional:
            error_message = f"{label} needs to have some value. It's Mandatory!"
            raise gr.Error(error_message, duration=None)

        # Handle boolean types (checkbox)
        if isinstance(value, bool):
            if append_value:
                # Append both tag and value
                option = option_to_append(cli_tag, value)
                if option:
                    cli_command.append(option)
            else:
                # Only append tag if true
                if value and cli_tag and cli_tag_is_valid(cli_tag):
                    cli_command.append(cli_tag)

        # Handle list types (inputs with file/image/measurement/etc.)
        elif isinstance(value, list):
            folder_name = item.get("folder_name")
            if not folder_name:
                if optional:
                    # optional file input; nothing to do
                    continue
                raise gr.Error(f"{label}: folder_name missing in spec.", duration=None)

            if not value:  # just in case
                if optional:
                    continue
                raise gr.Error(f"{label} needs a file. It's Mandatory!", duration=None)

            os.makedirs(folder_name, exist_ok=True)
            for file_path in value:
                shutil.copy(file_path, folder_name)
            value = folder_name
            if cli_tag and cli_tag_is_valid(cli_tag):
                option = option_to_append(cli_tag, value)
                if option:
                    cli_command.append(option)

        # Handle text output paths, check if it has a directory-name i.e. it's coming for declaring ouput path
        elif isinstance(value, str) and item_type == "textbox" and item.get("output_dir_set"):
            # -------------------------------------------------------------
            # This section handles 3 major scenarios:
            #   (1) User explicitly provides an output directory name
            #   (2) User doesnâ€™t provide one - Bilayers creates a default
            #   (3) Algorithm manages its own outputs (no CLI tag)
            # -------------------------------------------------------------
            output_dir_set = item.get("output_dir_set", False)
            cli_tag_present = cli_tag_is_valid(cli_tag)
            
            # Determine base output folder:
            # - If the spec declares output_dir_set=True, use user's folder
            # - Otherwise, fall back to a default base folder ("outputs/")                
            base_output_dir = value if output_dir_set else item.get("default", "outputs")
            
            # Construct a unique run-specific subfolder name to prevent overwriting
            # Example: outputs/run_20251013_1910_ab12        
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            unique_suffix = uuid.uuid4().hex[:4]
            unique_run_folder = os.path.join(base_output_dir, f"run_{timestamp}_{unique_suffix}")
            
            # Create new subfolder
            os.makedirs(unique_run_folder, exist_ok=True)
            output_folder_name = unique_run_folder
            
            if cli_tag_present:
                value = output_folder_name
                option = option_to_append(cli_tag, value)
                if option:
                    cli_command.append(option)

        # Handle all other types (radio, dropdown, textbox, number, etc.)
        elif value is not None:
            # Map radio/dropdown selections to values
            param_key = name.lower().replace(" ", "_")
            if param_key in radio_options and value in radio_options[param_key]:
                value = radio_options[param_key].get(value, value)
                
                if value == "ignore":
                    # Skip adding the whole "--cli_tag <value>" pair; if "ignore" is selected
                    continue
            
            # Add to command if cli_tag is valid
            if cli_tag and cli_tag_is_valid(cli_tag):
                option = option_to_append(cli_tag, value)
                if option:
                    cli_command.append(option)

    return " ".join(cli_command), folder_name, output_folder_name

def create_zip_from_files(output_files: list[str], output_folder_name: Optional[str]) -> Optional[str]:
    """
    Creates a zip archive from the output files and returns the zip path
    """
    if not output_files:
        return None

    base_dir = output_folder_name or os.getcwd()
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_name = f"outputs_{timestamp}.zip"
    zip_path = os.path.join(base_dir, zip_name)

    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf:
        for file_path in output_files:
            if os.path.isfile(file_path):
                zipf.write(file_path, arcname=os.path.basename(file_path))

    return zip_path

# Dynamically define on_submit with the exact parameter arguments
def on_submit(
{% if inputs -%}
{% for key, input_conf in inputs.items() -%}
{% if input_conf.get('type') in ['image', 'measurement', 'array', 'file', 'executable'] %}
{{ key | lower | replace(" ", "_") }}_description,
{{ key | lower | replace(" ", "_") }},
{% else %}
{{ key | lower | replace(" ", "_") }},
{%- endif %}
{%- endfor %}
{%- endif %}
{% if parameters -%}
{% for key, param_conf in parameters.items() -%}
{{ key | lower | replace(" ", "_") }},
{%- endfor %}
{%- endif %}
{% if display_only -%}
{% for key, display_only_conf in display_only.items() -%}
{{ key | lower | replace(" ", "_") }},
{%- endfor %}
{%- endif %}
):

    kwargs = {
    {% if inputs %}
    {% for key, input_conf in inputs.items() %}
        "{{ key | lower | replace(' ', '_') }}": {{ key | lower | replace(' ', '_') }},
    {% endfor %}
    {% endif %}
    {% if parameters %}
    {% for key, param_conf in parameters.items() %}
        "{{ key | lower | replace(' ', '_') }}": {{ key | lower | replace(' ', '_') }},
    {% endfor %}
    {% endif %}
    }

    print("Received parameters:", kwargs)

    # CLI sequence is passed in from the template context as a pre-ordered list
    cli_sequence = {{ cli_sequence | tojson | replace('true', 'True') | replace('false', 'False') | safe }}

    # Generate the CLI command using the pre-ordered sequence
    cli_command, folder_name, output_folder_name = generate_cli_command(cli_sequence, **kwargs)
    print("Generated CLI command:", cli_command)

    # Execute the CLI command
    try:
        result = subprocess.run(cli_command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("Command executed successfully")

        # Check if output_folder_name is not None and is a directory
        if output_folder_name and os.path.exists(output_folder_name) and os.path.isdir(output_folder_name):
            print("Folder exists")
            output_files = [os.path.join(output_folder_name, f)
                            for f in os.listdir(output_folder_name)
                            if os.path.isfile(os.path.join(output_folder_name, f))]
        else:
            # Fallback: collect all generated files
            possible_files = []
            fallback_folder = "outputs_fallback"
            os.makedirs(fallback_folder, exist_ok=True)

            for root, _, files in os.walk("."):
                for f in files:
                    if f.startswith(".") or f.endswith((".py", ".pyc", ".ipynb")):
                        continue
                    full_path = os.path.join(root, f)
                    possible_files.append(full_path)

            for file_path in possible_files:
                try:
                    shutil.copy(file_path, fallback_folder)
                except Exception as e:
                    print(f"Warning: could not copy {file_path}: {e}")

            output_files = [
                os.path.join(fallback_folder, f)
                for f in os.listdir(fallback_folder)
                if os.path.isfile(os.path.join(fallback_folder, f))
            ]
            output_folder_name = fallback_folder
            print(f"Collected {len(output_files)} output files in: {fallback_folder}")

        zip_path = create_zip_from_files(output_files, output_folder_name)
        return output_files, zip_path

    except subprocess.CalledProcessError as e:
        error_message = "Please take a screenshot of this error and raise an issue at the Bilayers repository on GitHub."
        error_message += f"Command failed with error: {e.stderr.decode()}\n\n"
        raise gr.Error(error_message, duration = None)
        
{% if inputs is not none and inputs | length > 0 -%}
{% for key, input_conf in inputs.items() %}

{% if input_conf.get('type') in ['image', 'measurement', 'array', 'file', 'executable'] %}
{{ key | lower | replace(" ", "_") }}_description = gr.Markdown(value="{{ input_conf.get('description', '') }}")
{{ key | lower | replace(" ", "_") }} = gr.Files(label="{{ input_conf.get('label', '') }}", file_count="{{ input_conf.get('file_count', 'single') }}")
{% endif %}

{% endfor %}
{%- endif %}

{% if parameters is not none and parameters | length > 0 -%}
{% for key, param_conf in parameters.items() %}

{% set param_label = key | lower | replace(" ", "_") %}

{% if param_conf.get('type') == 'radio' %}
{{ param_label }} = gr.Radio(label="{{ param_conf.get('label', '') }}", info="{{ param_conf.get('description', '') }}", choices=[{% for option in param_conf.get('options', []) %}"{{ option.label }}"{% if not loop.last %}, {% endif %}{% endfor %}], value="{{ param_conf.get('default', '') }}")
{% elif param_conf.get('type') == 'dropdown' %}
{{ param_label }} = gr.Dropdown(label="{{ param_conf.get('label', '') }}", info="{{ param_conf.get('description', '') }}", choices=[{% for option in param_conf.get('options', []) %}("{{ option.label }}", "{{ option.value }}"){% if not loop.last %}, {% endif %}{% endfor %}], value="{{ param_conf.get('default', '') }}", multiselect={{ param_conf.get('multiselect', False) }})
{% elif param_conf.get('type') in ['integer', 'float'] %}
{{ param_label }} = gr.Number(label="{{ param_conf.get('label', '') }}", info="{{ param_conf.get('description', '') }}", value={{ param_conf.get('default', 0) }} if "{{param_conf.get('type') }}" == "integer" else {{ param_conf.get('default', 0.0)}})
{% elif param_conf.get('type') == 'textbox' %}
{{ param_label }} = gr.Textbox(label="{{ param_conf.get('label', '') }}", info="{{ param_conf.get('description', '') }}", value="{{ param_conf.get('default', '') }}", interactive={{ param_conf.get('output_dir_set', True) }})
{% elif param_conf.get('type') == 'checkbox' %}
{{ param_label }} = gr.Checkbox(label="{{ param_conf.get('label', '') }}", info="{{ param_conf.get('description', '') }}", value={{ param_conf.get('default', False) }})
{% endif %}

{% endfor %}
{%- endif %}

{% if display_only is not none and display_only | length > 0 -%}
{% for key, display_only_conf in display_only.items() %}
{% set display_label = key | lower | replace(" ", "_") %}
    
{% if display_only_conf.get('type') == 'radio' %}
{{ display_label }} = gr.Radio(label="{{ display_only_conf.get('label', '') }} (Can't be changed, display only)", info="{{ display_only_conf.get('description', '') }}", choices=[{% for option in display_only_conf.get('options', []) %}"{{ option.label }}"{% if not loop.last %}, {% endif %}{% endfor %}], value="{{ display_only_conf.get('default', '') }}", interactive=False)    
{% elif display_only_conf.get('type') == 'dropdown' %}
{{ display_label }} = gr.Dropdown(label="{{ display_only_conf.get('label', '') }} (Can't be changed, display only)", info="{{ display_only_conf.get('description', '') }}", choices=[{% for option in display_only_conf.get('options', []) %}("{{ option.label }}", "{{ option.value }}"){% if not loop.last %}, {% endif %}{% endfor %}], value="{{ display_only_conf.get('default', '') }}", interactive=False, multiselect={{ display_only_conf.get('multiselect', False) }})
{% elif display_only_conf.get('type') in ['integer', 'float'] %}
{{ display_label }} = gr.Number(label="{{ display_only_conf.get('label', '') }} (Can't be changed, display only)", info="{{ display_only_conf.get('description', '') }}", value={{ display_only_conf.get('default', 0) }} if "{{ display_only_conf.get('type') }}" == "integer" else {{ display_only_conf.get('default', 0.0) }}, interactive=False)
{% elif display_only_conf.get('type') == 'textbox' %}
{{ display_label }} = gr.Textbox(label="{{ display_only_conf.get('label', '') }} (Can't be changed, display only)", info="{{ display_only_conf.get('description', '') }}", value="{{ display_only_conf.get('default', '') }}", interactive=False)
{% elif display_only_conf.get('type') == 'checkbox' %}
{{ display_label }} = gr.Checkbox(label="{{ display_only_conf.get('label', '') }} (Can't be changed, display only)", info="{{ display_only_conf.get('description', '') }}", value={{ display_only_conf.get('default', False) }}, interactive=False)
{% endif %}

{% endfor %}
{%- endif %}


all_parameters: list[Any] = [

{# Getting inputs #}
{% if inputs -%}
    {% for key, input_conf in inputs.items() -%}
        {% if input_conf.get('type') in ['image', 'measurement', 'array', 'file', 'executable'] -%}
            {{ key | lower | replace(" ", "_") }}_description,
            {{ key | lower | replace(" ", "_") }},
        {% else %}
            {{ key | lower | replace(" ", "_") }},
        {%- endif %}
    {%- endfor %}
{%- endif %}

{# Getting parameters #}
{% if parameters -%}
    {% for key, param_conf in parameters.items() -%}
        {{ key | lower | replace(" ", "_") }},
    {%- endfor %}
{%- endif %}

{# Getting display_only #}
{% if display_only -%}
    {% for key, display_only_conf in display_only.items() -%}
        {{ key | lower | replace(" ", "_") }},
    {%- endfor %}
{%- endif %}
]

download_results_from_here = gr.Files(label = "Download Output", file_count = "multiple")
download_all_zip = gr.DownloadButton(label = "Download All (zip)")

app = gr.Interface(
    fn=on_submit, 
    inputs=all_parameters,
    outputs=[download_results_from_here, download_all_zip], 
    title="{{ title }}",
    description="""{{ description }}""",
    allow_flagging="never",
)

if __name__ == "__main__":
    app.launch(server_name="0.0.0.0", server_port=7878, share=True)
