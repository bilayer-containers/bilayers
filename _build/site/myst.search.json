{"version":"1","records":[{"hierarchy":{"lvl1":"Interface"},"type":"lvl1","url":"/interface","position":0},{"hierarchy":{"lvl1":"Interface"},"content":"","type":"content","url":"/interface","position":1},{"hierarchy":{"lvl1":"Interface","lvl2":"What is Gradio?"},"type":"lvl2","url":"/interface#what-is-gradio","position":2},{"hierarchy":{"lvl1":"Interface","lvl2":"What is Gradio?"},"content":"Gradio provides a quick and easy way to demo your machine learning model through a user-friendly web interface, making it accessible to anyone, anywhere. \n\nLearn More\n","type":"content","url":"/interface#what-is-gradio","position":3},{"hierarchy":{"lvl1":"Interface","lvl2":"What is a Jupyter Notebook?"},"type":"lvl2","url":"/interface#what-is-a-jupyter-notebook","position":4},{"hierarchy":{"lvl1":"Interface","lvl2":"What is a Jupyter Notebook?"},"content":"Jupyter Notebooks offer a flexible, interactive environment where users can run and modify code. \n\nLearn More\n","type":"content","url":"/interface#what-is-a-jupyter-notebook","position":5},{"hierarchy":{"lvl1":"Creating an Interface for Your Custom Algorithm"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Creating an Interface for Your Custom Algorithm"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Creating an Interface for Your Custom Algorithm","lvl2":"Creating an Interface for Your Custom Algorithm"},"type":"lvl2","url":"/#creating-an-interface-for-your-custom-algorithm","position":2},{"hierarchy":{"lvl1":"Creating an Interface for Your Custom Algorithm","lvl2":"Creating an Interface for Your Custom Algorithm"},"content":"Bilayers allows you to easily create a web interface (using Gradio) or a Jupyter Notebook interface for any deep-learning cell segmentation algorithm by filling out a simple configuration file in YAML format. It’s as simple as filling out a Google Form!\nBefore you begin, let’s break down the key elements you need to know -\n\nInterface\nWhat is Gradio?\nWhat is JupyterNB?\n\nUnderstanding config.yaml requirements\nparameters\ndisplay_only\nresults\nexec_function\ndocker_image\nalgorithm_folder_name\ncitations\n\nSteps to create your custom Algorithm’s Interfaces\nStep 0: Clone the repo\nStep 1: Create your own Algorithm spec-file\nStep 2: Use the custom Docker Images\nStep 3: Raise the PR → Bilayers Team will approve and can publish the docker-image on docker-hub","type":"content","url":"/#creating-an-interface-for-your-custom-algorithm","position":3},{"hierarchy":{"lvl1":"Steps to create your custom algorithm's interface"},"type":"lvl1","url":"/steps-to-create","position":0},{"hierarchy":{"lvl1":"Steps to create your custom algorithm's interface"},"content":"","type":"content","url":"/steps-to-create","position":1},{"hierarchy":{"lvl1":"Understanding config.yaml file"},"type":"lvl1","url":"/understanding-config","position":0},{"hierarchy":{"lvl1":"Understanding config.yaml file"},"content":"To create your interface, you need to understand the structure of the config.yaml file and its key components:\n\nThe config.yaml file defines how the interface interacts with your algorithm. At the code level, it’s located at bilayers/src/algorithms/algorithm_name/config.yaml. The algorithm_name should reflect the task, such as cellpose_inference or cellpose_training, so name it accordingly.\n\nEach config.yaml contains key sections: parameters, display_only, results, exec_function, docker_image, algorithm_folder_name, and citations. You can copy the basic structure from an existing example.\n\nThis file is then converted into a CLI command, where user-provided inputs are passed as command-line arguments, enabling the retrieval of the desired output.\n\nparameters: These are key in building command-line arguments. Each object under this keyword forms part of the command line, with arguments either taken from the user or using default values.\n\ndisplay_only: These fields are displayed on the interface but aren’t included in the CLI command. No cli_tag should be passed to these objects; otherwise, they function like parameters.\n\nresults: Similar to parameters, but they define the expected output type and label it on the UI as the output. Typically, this is a file type.\n\nexec_function: Defines the function that converts the config.yaml into a Gradio or Jupyter Notebook interface. It also includes the initial part of the CLI command and a special hidden_args section if applicable.\n\ndocker_image: Contains details of the base image (organization, name, and tag) used to build the Docker image for each interface.\n\nalgorithm_folder_name: Specifies the folder where the generated Gradio and Jupyter Notebook files are stored.\n\ncitations: Used to reference relevant research or materials related to the algorithm.parameters:\n\ndisplay_only:\n\nresults:\n  \nexec_function:\n name: \"generate_cli_command\"\n script:\n module:\n cli_command:\n hidden_args:\n\ndocker-image:\n org:\n name:\n tag:\n\nalgorithm_folder_name:\n\ncitations:\n Algorithm:\n   - name: \"\"\n     doi: xxxx\n     description: \"\"\n\nBefore you start working on the config.yaml file, we recommend reviewing the command-line usage of the specific algorithm you’re building an interface for. This will help you determine what should go in parameters, display_only, results, and exec_function’s hidden_args.","type":"content","url":"/understanding-config","position":1},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Understanding cli_command"},"type":"lvl2","url":"/understanding-config#understanding-cli-command","position":2},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Understanding cli_command"},"content":"The cli_command is the starting point for executing the command line, like python -m cellpose, which is then followed by appending parameters and their arguments. We will cover more about cli_command in the context of the exec_function, but for now, it’s important to understand its role.","type":"content","url":"/understanding-config#understanding-cli-command","position":3},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Organizing Parameters from the Algorithm’s Command-Line Usage"},"type":"lvl2","url":"/understanding-config#organizing-parameters-from-the-algorithms-command-line-usage","position":4},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Organizing Parameters from the Algorithm’s Command-Line Usage"},"content":"parameters: If the parameter and its argument need to be passed in the command line, include them in parameters.\n\ndisplay_only: If you want to show some information to the user without appending it to the command line, include it in display_only.\n\nresults: Anything that you want to appear as output should go under results. For these, you can set the cli_tag as None.","type":"content","url":"/understanding-config#organizing-parameters-from-the-algorithms-command-line-usage","position":5},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining parameters"},"type":"lvl2","url":"/understanding-config#defining-parameters","position":6},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining parameters"},"content":"Each parameter object has mandatory tags, some of which depend on the parameter type. While the order of tags should generally be maintained, it’s okay if they are slightly rearranged.name: \ntype: \nlabel: \"\"\ndescription: \"\"\ndefault: \ncli_tag: \"\"\ncli_order: 0\noptional: True\nsection_id: \"\"\nmode: \"\"\n\nname: This should be a simple name, ideally matching the cli_tag (without hyphens). Use underscores instead of spaces.\nExample: name: use_gpu\n\ntype: This defines how the parameter will appear on the user interface. For example, if you want a Checkbox, the type should be set to checkbox.\nExample: type: checkbox\n\nBelow is a list of supported types and how they will appear in Gradio or Jupyter Notebook.\n\nTable 1:supported type in config.yaml\n\ntype(in config.yaml file)\n\nGradio\n\nJupyter Notebook\n\ncheckbox\n\nCheckbox\n\nCheckbox\n\ninteger\n\nNumber (decimal values allowed)\n\nIntText (allows to put Integer values)\n\nfloat\n\nNumber (decimal value allowed)\n\nFloatText (allows to put Float values)\n\nfiles\n\nDrag & Drop your files from local system\n\nVolume Mount supported (no need to put in files thru UI)\n\nradio\n\nRadio\n\nRadioButtons\n\ndropdown\n\nDropdown\n\nDropdown","type":"content","url":"/understanding-config#defining-parameters","position":7},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"Details on the type Tag","lvl2":"Defining parameters"},"type":"lvl3","url":"/understanding-config#details-on-the-type-tag","position":8},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"Details on the type Tag","lvl2":"Defining parameters"},"content":"type is the whole world in itself!\n\nWith the different type there are certain extra flags that you need to put in depending on the value of the flag type.\n\nTable 1:Understanding which extra flags are needed and their purpose\n\ntype\n\nExtra flag\n\nAccepted Values\n\nPurpose\n\ncheckbox\n\nappend_value\n\nTrue | False\n\nDetermines how the CLI command is constructed: - If append_value: True: - If user input is True: --cli_tag True - If user input is False: --cli_tag False - If append_value: False: - If user input is True: --cli_tag - If user input is False: No command appended.\n\ninteger\n\nfloat\n\nfiles\n\nfile_count\n\nsingle | multiple\n\nDefines how many files should be accepted: Note: - If file_count: multiple, the default must be \"directory\". - If file_count: single, the default must be \"single\".\n\nfiles\n\nfolder_name\n\n\"/bilayers/..\"\n\nSince the CLI argument only takes a folder name, specify it explicitly. This should also match the volume mount path when running the container.\n\ntextbox\n\noutput_dir_set (This is conditional and used only if output’s folder_path is specified through this flag. Additionally, set the default value to the folder path.)\n\nTrue | False\n\nDetermines whether the user can modify the folder path: - If True: The user can change the folder path. - If False: The path is fixed and cannot be modified, but the user can still view it.\n\nradio\n\n    options:\n        - label: GRAY\n        value: 0\n        - label: RED\n        value: 1\n        - label: GREEN\n        value: 2\n\nList of labels and values\n\nEach option has a label and value: - label: Displayed on the UI - value: Attached to the cli_tag based on the selected label.\n\ndropdown\n\n    options:\n        - label: GRAY\n          value: 0\n        - label: RED\n          value: 1\n        - label: GREEN\n          value: 2\n\nList of labels and values\n\nEach option has a label and value: - label: Displayed on the UI - value: Attached to the cli_tag based on the selected label.\n\ndropdown\n\nmultiselect\n\nFalse\n\nIt as of now only supports 1 value to be attached with a cli_tag\n\nAlso, here’s a collection of templates for each type that you can copy and paste directly into your config.yaml file.\n\nYou can find all types of templates listed below:\n\ntype: checkbox-   name: \n    type: checkbox\n    label: \"\"\n    description: \"\"\n    default: False\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    append_value: False\n    section_id: \"\"\n    mode: \"\"\n\ntype: integer-   name: \n    type: integer\n    label: \"\"\n    description: \"\"\n    default: 0\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode: \"\"\n\ntype: float-   name: \n    type: float\n    label: \"\"\n    description: \"\"\n    default: \n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode: \"\"\n\ntype: files, file_count: single-   name: \n    type: files\n    label: \"\"\n    description: \"\"\n    file_count: \"single\"\n    default: \"single\"\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    folder_name: \"\"\n    mode: \"\"\n\ntype: files, file_count: multiple-   name: \n    type: files\n    label: \"\"\n    description: \"\"\n    file_count: \"multiple\"\n    default: \"directory\"\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    folder_name: \"\"\n    mode: \"\"\n\ntype: textbox (standard textbox)-   name: \n    type: textbox\n    label: \"\"\n    description: \"\"\n    default: \"\"\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode: \"\"\n\ntype: textbox (specifying folder path in default)-   name: \n    type: textbox\n    label: \"\"\n    description: \"\"\n    output_dir_set: True\n    default: \"/bilayers/my_folder_name\"\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode:\n\ntype: radio-   name: \n    type: radio\n    label: \"\"\n    description: \"\"\n    options: \n    - label: \n      value: \n    - label: \n      value: \n    default: \n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode: \"\"\n\ntype: dropdown-   name: \n    type: dropdown\n    label: \"\"\n    description: \"\"\n    options: \n    - label: \n      value: \n    - label:\n      value: \n    default: True\n    multiselect: False\n    cli_tag: \"\"\n    cli_order: 0\n    optional: True\n    section_id: \"\"\n    mode: \"\"","type":"content","url":"/understanding-config#details-on-the-type-tag","position":9},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining display_only"},"type":"lvl2","url":"/understanding-config#defining-display-only","position":10},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining display_only"},"content":"display_only functions similarly to parameters, but the key difference is that these objects are only displayed in the user interface and are not appended to the cli_command. They are non-interactive, meaning users cannot modify the values, which will always reflect the default specified in the config.yaml file.\n\nSince they are not part of the cli_command, you can omit cli_tag and cli_order. For the rest of the structure, you can reuse the template from parameters based on the object type.","type":"content","url":"/understanding-config#defining-display-only","position":11},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining results"},"type":"lvl2","url":"/understanding-config#defining-results","position":12},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining results"},"content":"results represent the outputs or results generated after executing the command. In most cases, this will be defined as type: files. The structure follows the same format as parameters, but currently, Bilayers only supports type: files. If you require additional result types, please submit a feature request here.\n\nFor results, the cli_tag should always be set to “None,” and there’s no need to specify cli_order.\n\nNote that results are not typically sourced from the documentation.results:\n  - name: output_dir\n    type: Files\n    label: \"Download Outputs\"\n    description: \"\"\n    cli_tag : \"None\"\n    optional: True\n    section_id: \"output-section\"\n    mode: \"\"","type":"content","url":"/understanding-config#defining-results","position":13},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining exec_function"},"type":"lvl2","url":"/understanding-config#defining-exec-function","position":14},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining exec_function"},"content":"exec_function is instrumental in converting the yaml file to desired interface. It defines the specific function responsible for this conversion. The exec_function consists of the following components: name, script, module, cli_command, and hidden_args.\n\nBelow is the template to attach directly to your configuration file, followed by a breakdown:exec_function:\n name: \"generate_cli_command\"\n script: \"\"\n module: \"Algorithms.\"\n cli_command: \"\"\n hidden_args:\n   # dummy example\n   # - cli_tag: \"--save_png\"\n   #   value: \"True\"\n   #   append_value: False\n   #   cli_order: 3\n\nBelow is an example to follow, along with a breakdown of each component:exec_function:\n name: \"generate_cli_command\"\n script: \"cellpose_inference\"\n module: \"Algorithms.cellpose_inference\"\n cli_command: \"python -m cellpose --verbose\"\n hidden_args:\n   # dummy example\n   # - cli_tag: \"--save_png\"\n   #   value: \"True\"\n   #   append_value: False\n   #   cli_order: 3\n\nname: This is the name of the function that converts the yaml file into the interface dynamically. It remains the same for all algorithms, so no changes are needed.\nname: “generate_cli_command”\n\nscript: The name of the algorithm’s parent folder, which can either be algorithm_inference or algorithm_training.Example: script: “cellpose_inference”\n\nmodule: The module name for the algorithm, followed by the script name, separated by a dot.\nExample: module: “Algorithms.cellpose_inference”\n\ncli_command: As mentioned earlier, the cli_command refers to the module execution in the documentation. This serves as the starting point, and the cli_tag and argument pairs are appended to it. Refer to the documentation for proper configuration.\n\nIn command-line systems, there are several common command line patterns used for constructing a cli_command. Here, we support several widely used patterns: \n\nExplore the full discussion here\n\nsomeexecutable --unordered_flag_1 unordered_value_1  --unordered_flag_2 unordered_value_2\n\nsomeexecutable unordered_value_1 unordered_value_2\n\nsomeexecutable ordered_value_1 unordered_value_2\n\nsomeexecutable --ordered_flag_1 ordered_value_1 unordered_value_2\n\nsomeexecutable ordered_value_1 --unordered_flag_2 unordered_value_2\n\nsomeexecutable --unordered_flag_1=unordered_value_1 --unordered_flag_2 unordered_value_2\n\nsomeexecutable --ordered_flag_1=ordered_value_1 unordered_value_2","type":"content","url":"/understanding-config#defining-exec-function","position":15},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"What are ordered_flag and unordered_flag?","lvl2":"Defining exec_function"},"type":"lvl3","url":"/understanding-config#what-are-ordered-flag-and-unordered-flag","position":16},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"What are ordered_flag and unordered_flag?","lvl2":"Defining exec_function"},"content":"In some cases, cli_command requires flags in fixed positions (e.g., always the 1st or last argument). To handle this, we use the cli_order flag. Here’s how it works:\n\nSpecify a positive number (1 to n) in cli_order to fix the position of the cli_flag and argument pair.\n\nIf cli_order is set to 0 or not specified, it will be treated as an unordered_flag, and all such flags will appear after ordered ones.\n\nNegative numbers in cli_order will place the flag in the last position, after all unordered flags.","type":"content","url":"/understanding-config#what-are-ordered-flag-and-unordered-flag","position":17},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"How to specify --flag_1=value_1?","lvl2":"Defining exec_function"},"type":"lvl3","url":"/understanding-config#how-to-specify-flag-1-value-1","position":18},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"How to specify --flag_1=value_1?","lvl2":"Defining exec_function"},"content":"By default, flags and their arguments are appended with a space between them. If you want to use = between the flag and value, simply add an = at the end of cli_tag.\nFor example,\ncli_tag: “--savedir=”\ndefault: “/bilayers/my_outputs”\nThis will generate: someexecutable --savedir=/bilayers/my_outputs","type":"content","url":"/understanding-config#how-to-specify-flag-1-value-1","position":19},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"hidden_args: Need of hidden_args?","lvl2":"Defining exec_function"},"type":"lvl3","url":"/understanding-config#hidden-args-need-of-hidden-args","position":20},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"hidden_args: Need of hidden_args?","lvl2":"Defining exec_function"},"content":"Sometimes, certain cli_tag and argument values should always be included in the cli_command, but you don’t want to expose them in the user interface. In these cases, use hidden_args.","type":"content","url":"/understanding-config#hidden-args-need-of-hidden-args","position":21},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"Where can it be used?","lvl2":"Defining exec_function"},"type":"lvl3","url":"/understanding-config#where-can-it-be-used","position":22},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl3":"Where can it be used?","lvl2":"Defining exec_function"},"content":"A potential use case for hidden_args is ensuring output files are saved to a specific folder without allowing the user to modify it. If the algorithm’s command-line usage includes a specific cli_tag for this, you can define it as a hidden_arg. Use the following fields to configure hidden_args:\n\ncli_tag: The command-line tag to be used.\n\nvalue: The fixed value for the tag.\n\nappend_value: (Optional) Used for checkbox type to specify whether the value should be appended with the cli_tag.\n\ncli_order: (Optional) Specifies the order in which this tag should appear in the cli_command. If not set, it will appear after all ordered tags but before any negatively indexed ones.","type":"content","url":"/understanding-config#where-can-it-be-used","position":23},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining docker_image"},"type":"lvl2","url":"/understanding-config#defining-docker-image","position":24},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining docker_image"},"content":"Each interface’s Docker image is built on top of the base Docker image specific to the algorithm. Therefore, it’s highly recommended to choose an algorithm with a pre-built Docker image available on DockerHub.\n\nTo specify the image, select one from DockerHub. Here’s how it works with an example:For instance, cellprofiler/runcellpose_no_pretrained:0.1 can be broken down into three parts:\n\norg: The part before / is the username or organization (e.g., cellprofiler).\n\nname: The part between / and : is the image name (e.g., runcellpose_no_pretrained).\n\ntag: The part after : is the tag, which can be a version number or a term like latest (e.g., 0.1).\n\nTo learn more about docker image naming, refer to What are Docker tags?\n\nAlso, here’s the template to directly paste in your config.yaml filedocker-image:\n org: \n name: \n tag:","type":"content","url":"/understanding-config#defining-docker-image","position":25},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining algorithm_folder_name"},"type":"lvl2","url":"/understanding-config#defining-algorithm-folder-name","position":26},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining algorithm_folder_name"},"content":"This specifies the folder where the generated Gradio and Jupyter Notebook interface files will be stored. The folder name should follow the convention of the config.yaml’s parent folder, such as algorithm_inference or algorithm_training.Example: algorithm_folder_name: “cellpose_inference”","type":"content","url":"/understanding-config#defining-algorithm-folder-name","position":27},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining citations"},"type":"lvl2","url":"/understanding-config#defining-citations","position":28},{"hierarchy":{"lvl1":"Understanding config.yaml file","lvl2":"Defining citations"},"content":"Citations are used to credit the relevant works associated with the algorithm. Include the correct name, DOI, and description of the algorithm. Guidelines on how to find citations can be found here. Note that interface citations are added dynamically, so you don’t need to include them manually.citations:\n Algorithm:\n   - name: \"cite-1\"\n     doi: \n     description: \"\"\n   - name: \"cite-2\"\n     doi: \n     description: \"\"\n\nSample Example:citations:\n Algorithm:\n   - name: \"Cellpose\"\n     doi: 10.1038/s41592-020-01018-x\n     description: \"Deep Learning algorithm for cell segmentation in microscopy images\"","type":"content","url":"/understanding-config#defining-citations","position":29},{"hierarchy":{"lvl1":"What is Bilayers?"},"type":"lvl1","url":"/whatisbilayers","position":0},{"hierarchy":{"lvl1":"What is Bilayers?"},"content":"","type":"content","url":"/whatisbilayers","position":1},{"hierarchy":{"lvl1":"What is Bilayers?"},"type":"lvl1","url":"/whatisbilayers#what-is-bilayers","position":2},{"hierarchy":{"lvl1":"What is Bilayers?"},"content":"Bilayers is an open-source specification designed to characterize software containers in terms of expected inputs, expected outputs, and tunable parameters. Its primary aim is to make bioimage analysis deep-learning algorithms more accessible by automatically generating intuitive, no-terminal-required user interfaces. Bilayers ensures that software containers can be deployed consistently across different environments, from small prototypes to large-scale workflows, without the risk of version mismatch.\n\nBilayers currently supports interfaces like Gradio and Jupyter Notebook and plans to expand to others, such as CellProfiler plugins. Each algorithm-interface pair is containerized and published as a Docker image on DockerHub, allowing users to run the tool effortlessly by spinning up a Docker container. You can start using it right away — No Coding or Complicated Installations needed!\n\nIn addition to using pre-built Docker images provided by Bilayers, you can also create your own web interface or Jupyter Notebook interface for custom deep-learning algorithms. You can even fine-tune algorithms from the BioImage Model Zoo by simply filling out a configuration file (as long as the algorithm’s Docker image is available on DockerHub). Bilayers offers a simple, interactive interface with widgets like number inputs, text fields, radio buttons, dropdown menus, image upload options and more. This makes it easy to tweak parameters and input your images for analysis, giving you the desired output with minimal effort.\n\nIt ensures that the same containerized algorithms used in prototypes can be reliably deployed in large-scale workflows without version drift, whether on local machines, high-performance computing (HPC) systems, or in the cloud. This also helps sysadmins create and validate workflows for end users in tools like Nextflow or Snakemake.\n\nBilayers is open-source, and we welcome contributions! You can create an interface for your custom deep-learning algorithm using Bilayers, and if you’d like, we can publish it on DockerHub to benefit the broader bioimaging community.","type":"content","url":"/whatisbilayers#what-is-bilayers","position":3},{"hierarchy":{"lvl1":"What are containers?"},"type":"lvl1","url":"/whatisbilayers#what-are-containers","position":4},{"hierarchy":{"lvl1":"What are containers?"},"content":"Containers are lightweight piece of software that contains all the code, libraries, and dependencies that the application needs to run. Containers do not have their own operating system, they get resources from the host operating system. They are also easily portable as they contain all the libraries and the dependencies to run the application.","type":"content","url":"/whatisbilayers#what-are-containers","position":5},{"hierarchy":{"lvl1":"What is Docker?"},"type":"lvl1","url":"/whatisbilayers#what-is-docker","position":6},{"hierarchy":{"lvl1":"What is Docker?"},"content":"Docker is a containerization platform that allows you to package code and dependencies into a Docker image that can be run on any machine. It allows your application to be separated from your infrastructure. The image that you created is portable, so you can run it on any machine that has Docker installed.","type":"content","url":"/whatisbilayers#what-is-docker","position":7},{"hierarchy":{"lvl1":"Quick Links"},"type":"lvl1","url":"/whatisbilayers#quick-links","position":8},{"hierarchy":{"lvl1":"Quick Links"},"content":"","type":"content","url":"/whatisbilayers#quick-links","position":9},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Getting Started with Pre-Built Docker Images"},"type":"lvl2","url":"/whatisbilayers#getting-started-with-pre-built-docker-images","position":10},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Getting Started with Pre-Built Docker Images"},"content":"Learn how to quickly start using Bilayers with our pre-built Docker images. Start Here","type":"content","url":"/whatisbilayers#getting-started-with-pre-built-docker-images","position":11},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Creating an Interface for Your Custom Algorithm"},"type":"lvl2","url":"/whatisbilayers#creating-an-interface-for-your-custom-algorithm","position":12},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Creating an Interface for Your Custom Algorithm"},"content":"Follow our guide to create a web or Jupyter Notebook interface for your deep-learning algorithm. \n\nLearn More","type":"content","url":"/whatisbilayers#creating-an-interface-for-your-custom-algorithm","position":13},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Contribution & Developer Guidelines"},"type":"lvl2","url":"/whatisbilayers#contribution-developer-guidelines","position":14},{"hierarchy":{"lvl1":"Quick Links","lvl2":"Contribution & Developer Guidelines"},"content":"Want to contribute to Bilayers? Check out our developer guidelines and learn how to submit your custom interfaces. Read the Guidelines","type":"content","url":"/whatisbilayers#contribution-developer-guidelines","position":15}]}