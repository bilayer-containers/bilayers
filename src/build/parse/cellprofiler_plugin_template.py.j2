####################################
# Auto-Generated CellProfiler Plugin
# Generated from Bilayers Spec File
####################################

#################################
#
# Imports from Python Standard Libraries
#
##################################

import numpy
import os
import skimage
import importlib.metadata
import subprocess
import uuid
import shutil
import logging
import sys

#################################
#
# Imports from CellProfiler
#
##################################

from cellprofiler_core.setting import Binary, Choice, Directory, Filename, Float, Integer
from cellprofiler_core.setting.text import Filename, ImageName
from cellprofiler_core.module.image_segmentation import ImageSegmentation
from cellprofiler_core.object import Object
from cellprofiler_core.pipeline import Pipeline
from cellprofiler_core.image import Image

LOGGER = logging.getLogger(__name__)

__doc__ = f"""\
{{ exec_function.get('script') }}
===========

**{{ exec_function.get('script') }}** is an auto-generated CellProfiler module based on Bilayers specification.

{%- for citation in citations.algorithm.values() %}
This module uses **{{ citation.name }}** i.e. {{ citation.description }}.

To cite this module, use:
- **DOI**: {{ citation.doi }}
- **License**: {{ citation.license }}
{%- endfor %}

============ ============ ===============
Supports 2D? Supports 3D? Respects masks?
============ ============ ===============

============ ============ ===============
"""

class {{ exec_function.get('script') }}({{ exec_function.get('module') }}):
    category = "{{ tool.category }}"

    module_name = "{{ exec_function.get('script') }}"

    variable_revision_number = 1

    doi = {
        {%- for citation in citations.algorithm.values() %}
        "This module uses {{ citation.name }} i.e. {{ citation.description }}"
        "To cite this module, use:"
        "- **DOI**: {{ citation.doi }}"
        "- **License**: {{ citation.license }}"
        {%- endfor %}
    }

    def create_settings(self):
        super({{ exec_function.get('script') }}, self).create_settings()
        
        {% set type_mapping = {
            "image": "Filename",
            "measurement": "Filename",
            "array": "Filename",
            "executable": "Filename",
            "file": "Filename",
            "radio": "Choice",
            "dropdown": "Choice",
            "checkbox": "Binary",
            "integer": "Integer",
            "float": "Float",
            "textbox": "ImageName",
        } %}
        {% set default_type = "Text" %} {# Fallback type #}

        self.docker_or_python = Choice(
            text="{{ exec_function.get('script') }} in docker or local python environment",
            choices=["Docker", "Python"],
            value="Docker",
            doc="""\
If Docker is selected, ensure that Docker Desktop is open and running on your
computer. On first run of the X plugin, the Docker container will be
downloaded, which may be slow . However, this slow downloading process will only have to happen
once.

If Python is selected, the Python environment in which CellProfiler is installed will be used.
""",
        )

        self.docker_image = Choice(
            text="Select your external docker image",
            {# choices=["{{ docker_image.get('org') }}/{{ docker_image.get('name') }}:{{ docker_image.get('tag') }}"], #}
            {# value="{{ docker_image.get('org') }}/{{ docker_image.get('name') }}:{{ docker_image.get('tag') }}", #}
            choices="gibberish",
            value="gibberish",
            doc="""\
Select which Docker image to use for running your plugin.
"""
        )
        
        {% for key, input_conf in inputs.items() %}
        self.{{ input_conf.get('name') }} = {{ type_mapping[input_conf.get('type')] }}(
            text="{{ input_conf.get('label') }}",
            {% if input_conf.get('default') is not none %}
            value="{{ input_conf.get('default') }}",
            {% endif %}
            doc="{{ input_conf.get('description') }}"

        )
        {% endfor %}

        {% for key, parameter in parameters.items() %}
        self.{{ parameter.get('name') }} = {{ type_mapping[parameter.get('type')] }}(
            text="{{ parameter.get('label') }}",
            {% if parameter.get('type') in ["radio", "dropdown"] %}
            choices=[
                {% for option in parameter.get('options') %}
                    "{{ option.value }}"{% if not loop.last %}, {% endif %}
                {% endfor %}
            ],
            {% endif %}
            {% if parameter.get('default') is not none %}
            value="{{ parameter.get('default') }}",
            {% endif %}
            {% if parameter.get('type') in ["integer", "float"] %}
            minval=float('-inf'),
            maxval=float('inf'),
            {% endif %}
            doc="{{ parameter.get('description') }}"
        )
        {% endfor %}
{# Commmmenet --------- Ignoreee -------------- #}
        {# self.input_image = cellprofiler_core.setting.subscriber.ImageSubscriber(
            "Input Image", doc="Select the input image."
        )

        self.output_image = cellprofiler_core.setting.subscriber.ImageProvider(
            "Output Image", doc="Name the output image."
        )

        {% for setting in settings %}
        self.{{ setting.name }} = cellprofiler_core.setting.{{ setting.type }}(
            "{{ setting.label }}", value={{ setting.default }},
            doc="{{ setting.doc }}"
        )
        {% endfor %} #}

{# Commmmenet --------- Ignoreee -------------- #}
        
    def settings(self):

        return [
        self.x_name,
        self.docker_or_python,
        self.docker_image,
        {% for key, input_conf in inputs.items() %}
        self.{{ input_conf.get('name') }},
        {% endfor %}
        {% for key, param in parameters.items() %}
        self.{{ param.get('name') }},
        {% endfor %}
        self.y_name,
        ]    

    def run(self, workspace):
        # 1. Retrive Input and Output Names + Load Input Image
        x_name = self.x_name.value
        y_name = self.y_name.value

        images = workspace.image_set
        x = images.get_image(x_name)
        x_data = x.pixel_data
        dimensions = x.dimensions

        # 2. Preprocessing Stuff

        # 3. Choose Execution Method
        if self.docker_or_python.value == "Python":
            # Run algorithm in Python
            try:
                y_data = somefunction(
                    x_data,
                    {% for param in parameters.values() %}
                    self.{{ param.get('name') }}.value,
                    {% endfor %}
                )
            except Exception as e:
                print(f"Error in Python execution: {e}")
        
        elif self.docker_or_python.value == "Docker":
            # Docker binary path (Windows vs Unix)
            docker_path = "docker" if sys.platform.lower().startswith("win") else "/usr/local/bin/docker"
            
            # Create a unique folder for this run
            unique_name = str(uuid.uuid4())
            temp_dir = os.path.join(get_default_output_directory(), ".cellprofiler_temp", unique_name)
            temp_img_dir = os.path.join(temp_dir, "img")
            
            os.makedirs(temp_dir, exist_ok=True)
            os.makedirs(temp_img_dir, exist_ok=True)
            
            temp_img_path = os.path.join(temp_img_dir, unique_name+".tiff")

            # Save the input image in docker mounted path
            skimage.io.imsave(temp_img_path, x_data)

            # Construct Docker command
            cmd = [docker_path, "run", "--rm", "-v", f"{temp_dir}:/data", self.docker_image.value]
            {% for key, input_conf in inputs.items() %}
            cmd += ["{{ input_conf.get('cli_tag') }}", str(self.{{ input_conf.get('name') }}.value)]
            {% endfor %}
            {% for key, param in parameters.items() %}
            cmd += ["{{ param.get('cli_tag') }}", str(self.{{ param.get('name') }}.value)]
            {% endfor %}

            # Test -if this is working
            {# print("Docker command:", " ".join(cmd)) #}

            try:
                subprocess.run(cmd, text=True)
                # Load the segmentation output
                y_data = numpy.load(os.path.join(temp_img_dir, "segmentation.npy"), allow_pickle=True).item()
            finally:
                # Clean up temporary directory
                try:
                    shutil.rmtree(temp_dir)
                except:
                    LOGGER.error("Unable to delete temporary directory. Files may be in use.")

        
        # 4. Store and Display Results
        # Store segmented objects
        y = Objects()
        y.segmented = y_data
        y.parent_image = x.parent_image
        workspace.object_set.add_objects(y, y_name)

        # Save measurements
        self.add_measurements(workspace)

        # Display results in UI
        if self.show_window:
            workspace.display_data.x_data = x.pixel_data if x.volumetric else x_data
            workspace.display_data.y_data = y_data
            workspace.display_data.dimensions = dimensions

    def visible_settings(self):
        vis_settings = [
            
        ]
        return vis_settings

    

    def display(self, workspace, figure):
        pass
    
    def upgrade_settings(self, setting_values, variable_revision_number, module_name):
        return setting_values, variable_revision_number